using System.Globalization;
using System.IO.Pipes;
using System.Security.Cryptography;
using System.Text;
using CsvHelper;
using CsvHelper.Configuration;
using eID.PJS.API.DTOs;
using eID.PJS.API.Options;
using eID.PJS.API.Requests;
using eID.PJS.AuditLogging;
using eID.PJS.Contracts;
using eID.PJS.Contracts.Commands.Admin;
using eID.PJS.Contracts.Results;
using eID.PJS.Contracts.Results.Admin;
using eID.PJS.LocalLogsSearch.API.Authorization;
using MassTransit;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Options;
using Newtonsoft.Json;

namespace eID.PJS.API.Controllers;

[RoleAuthorization(UserRoles.AuditAdministrator)]
public class LogController : BaseV1Controller
{
    private readonly StorageOptions _storageOptions;
    private readonly AesOptions _aesOptions;

    public LogController(
        ILogger<LogController> logger,
        IConfiguration configuration,
        AuditLogger auditLogger,
        IOptions<StorageOptions> storageOptions,
        IOptions<AesOptions> aesOptions) : base(logger, configuration, auditLogger)
    {
        _storageOptions = (storageOptions ?? throw new ArgumentNullException(nameof(storageOptions))).Value;
        _storageOptions.Validate();
        _aesOptions = (aesOptions ?? throw new ArgumentNullException(nameof(aesOptions))).Value;
        _aesOptions.Validate();
    }

    /// <summary>
    /// This endpoint gets log information generated by calling user's activity in the system
    /// </summary>
    /// <param name="client"></param>
    /// <param name="request"></param>
    /// <param name="cancellationToken"></param>
    /// <returns></returns>
    [HttpPost("from")]
    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(CursorResult<LogFromUserResult>))]
    public async Task<IActionResult> GetLogFromUserAsync(
        [FromServices] IRequestClient<GetLogFromUser> client,
        GetLogUserFromMeRequest request,
        CancellationToken cancellationToken)
    {
        var logEventCode = LogEventCode.GET_LOG_FROM_USER;
        var eventPayload = BeginAuditLog(logEventCode, request, targetUserId: request.UserId);
        if (!request.IsValid())
        {
            return BadRequestWithAuditLog(request, logEventCode, eventPayload, targetUserId: request.UserId);
        }

        var serviceResult = await GetResponseAsync(() =>
            client.GetResponse<ServiceResult<CursorResult<LogFromUserResult>>>(
                new
                {
                    CorrelationId = RequestId,
                    request.UserEid,
                    request.UserId,
                    request.EventId,
                    request.RequesterUid,
                    request.RequesterUidType,
                    request.TargetUid,
                    request.TargetUidType,
                    request.TargetName,
                    request.StartDate,
                    request.EndDate,
                    request.EventTypes,
                    request.CursorSize,
                    request.CursorSearchAfter
                }, cancellationToken));

        return ResultWithAuditLog(serviceResult, logEventCode, eventPayload, targetUserId: request.UserId);
    }

    /// <summary>
    /// This endpoint gets log information generated by calling user's activity and return it as CSV file.
    /// There are two possible results:
    ///  - 202 Accepted -> file isn't prepared yet
    ///  - 200 OK with streamed file content
    /// </summary>
    /// <param name="publishEndpoint"></param>
    /// <param name="request"></param>
    /// <param name="cancellationToken"></param>
    /// <returns></returns>
    [HttpPost("from/export/csv")]
    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(File))]
    [ProducesResponseType(StatusCodes.Status202Accepted)]
    public async Task<IActionResult> GetLogFromUserAsCSVAsync(
    [FromServices] IPublishEndpoint publishEndpoint,
    [FromBody] GetLogFromUserAsCSVRequest request,
    CancellationToken cancellationToken)
    {
        if (!request.IsValid())
        {
            return BadRequest(request);
        }

        // Prepare file name
        var requestStr = JsonConvert.SerializeObject(request, Formatting.None);
        var requestBytes = Encoding.UTF8.GetBytes(requestStr);
        var hash = SHA256.HashData(requestBytes);
        var hashStr = BitConverter.ToString(hash).Replace("-", string.Empty);
        var fileName = $"report_from_{hashStr}-{request.StartDate:yyyyMMdd}-{request.EndDate:yyyyMMdd}.json";

        var fileFullPath = Path.Combine(Path.GetFullPath(_storageOptions.ExportAuditLogsCsvFilesLocation), fileName);

        // If the file is not found or isn't in process (missing .tmp) send message to prepare it
        if (!System.IO.File.Exists(fileFullPath))
        {
            var tempFile = fileFullPath + Constants.FileProcess.TempFileExtension;
            if (!System.IO.File.Exists(tempFile))
            {
                await publishEndpoint.Publish<GetLogFromUserAsFile>(
                    new
                    {
                        CorrelationId = RequestId,
                        request.UserEid,
                        request.UserId,
                        request.EventId,
                        request.RequesterUid,
                        request.RequesterUidType,
                        request.TargetUid,
                        request.TargetUidType,
                        request.TargetName,
                        request.StartDate,
                        request.EndDate,
                        request.EventTypes,
                        fileFullPath
                    }, cancellationToken);
            }

            AddAuditLog(LogEventCode.GET_LOG_FROM_USER, LogEventLifecycle.SUCCESS, payload: new SortedDictionary<string, object>
            {
                { AuditLoggingKeys.Request, request },
                { AuditLoggingKeys.RequesterUid, GetUid() },
                { AuditLoggingKeys.RequesterUidType, GetUidType() },
                { "UserId", GetUserId() }
            });

            return Accepted();
        }

        var csvFileName = $"report_fromUser-{request.StartDate:yyyyMMdd}-{request.EndDate:yyyyMMdd}.csv";

        // Creating a pipe stream to transform the JSON lines at write time.
        var pipeStream = new AnonymousPipeServerStream(PipeDirection.Out);
        var clientStream = new AnonymousPipeClientStream(PipeDirection.In, pipeStream.GetClientHandleAsString());
        
        Response.RegisterForDisposeAsync(pipeStream);
        Response.RegisterForDisposeAsync(clientStream);

        _ = Task.Run(async () =>
        {
            await using var writer = new StreamWriter(pipeStream, Encoding.UTF8);
            var csvConfig = new CsvConfiguration(CultureInfo.InvariantCulture)
            {
                Encoding = Encoding.UTF8,
                HasHeaderRecord = true,
                NewLine = Environment.NewLine,
            };
            await using var csv = new CsvWriter(writer, csvConfig);

            using var aes = Aes.Create();
            aes.Key = Encoding.UTF8.GetBytes(_aesOptions.Key);
            aes.Mode = CipherMode.ECB;
            aes.Padding = PaddingMode.PKCS7;
            var decryptor = aes.CreateDecryptor(aes.Key, aes.IV);

            csv.WriteHeader(typeof(LogFromUserResultDTO));
            await csv.NextRecordAsync();

            using var readStream = System.IO.File.Open(fileFullPath, FileMode.Open, FileAccess.Read, FileShare.Read);
            using var reader = new StreamReader(readStream);
            string? line;
            while ((line = await reader.ReadLineAsync()) != null && !cancellationToken.IsCancellationRequested)
            {
                var data = JsonConvert.DeserializeObject<LogFromUserResult>(line);
                if (data == null) continue;

                DecryptLogRecordData(data, decryptor);
                var dto = LogFromUserResultDTO.Create(data);

                csv.WriteRecord(dto);
                await csv.NextRecordAsync();
            }

            await csv.FlushAsync();
            await writer.FlushAsync();
            await pipeStream.FlushAsync(cancellationToken);
        }, cancellationToken);

        return File(clientStream, "text/csv", csvFileName);
    }


    /// <summary>
    /// This endpoint gets log information for every action targeting the calling user
    /// </summary>
    /// <param name="client"></param>
    /// <param name="request"></param>
    /// <param name="cancellationToken"></param>
    /// <returns></returns>
    [HttpPost("to")]
    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(CursorResult<LogToUserResult>))]
    public async Task<IActionResult> GetLogToUserAsync(
        [FromServices] IRequestClient<GetLogToUser> client,
        GetLogToUserRequest request,
        CancellationToken cancellationToken)
    {
        var logEventCode = LogEventCode.GET_LOG_TO_USER;
        var eventPayload = BeginAuditLog(logEventCode, request, targetUserId: request.UserId);
        if (!request.IsValid())
        {
            return BadRequestWithAuditLog(request, logEventCode, eventPayload, targetUserId: request.UserId);
        }

        var serviceResult = await GetResponseAsync(() =>
            client.GetResponse<ServiceResult<CursorResult<LogToUserResult>>>(
                new
                {
                    CorrelationId = RequestId,
                    request.UserId,
                    request.EventId,
                    request.RequesterUid,
                    request.RequesterUidType,
                    request.TargetUid,
                    request.TargetUidType,
                    request.TargetName,
                    request.StartDate,
                    request.EndDate,
                    request.EventTypes,
                    request.CursorSize,
                    request.CursorSearchAfter
                }, cancellationToken));

        return ResultWithAuditLog(serviceResult, logEventCode, eventPayload, targetUserId: request.UserId);
    }

    /// <summary>
    /// This endpoint gets log information for every action targeting the calling user as CSV file
    /// There are two possible results:
    ///  - 202 Accepted -> file isn't prepared yet
    ///  - 200 OK with streamed file content
    /// </summary>
    /// <param name="publishEndpoint"></param>
    /// <param name="request"></param>
    /// <param name="cancellationToken"></param>
    /// <returns></returns>
    [HttpPost("to/export/csv")]
    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(File))]
    [ProducesResponseType(StatusCodes.Status202Accepted)]
    public async Task<IActionResult> GetLogToUserAsCSVAsync(
    [FromServices] IPublishEndpoint publishEndpoint,
    [FromBody] GetLogToUserAsCSVRequest request,
    CancellationToken cancellationToken)
    {
        if (!request.IsValid())
        {
            return BadRequest(request);
        }

        // Prepare file name
        var requestStr = JsonConvert.SerializeObject(request, Formatting.None);
        var requestBytes = Encoding.UTF8.GetBytes(requestStr);
        var hash = SHA256.HashData(requestBytes);
        var hashStr = BitConverter.ToString(hash).Replace("-", string.Empty);
        var jsonFileName = $"report_to_{hashStr}-{request.StartDate:yyyyMMdd}-{request.EndDate:yyyyMMdd}.json";

        var fileFullPath = Path.Combine(Path.GetFullPath(_storageOptions.ExportAuditLogsCsvFilesLocation), jsonFileName);

        // If the file is not found or isn't in process (missing .tmp) send message to prepare it
        if (!System.IO.File.Exists(fileFullPath))
        {
            var tempFile = fileFullPath + Constants.FileProcess.TempFileExtension;
            if (!System.IO.File.Exists(tempFile))
            {
                await publishEndpoint.Publish<GetLogToUserAsFile>(
                    new
                    {
                        CorrelationId = RequestId,
                        request.UserId,
                        request.EventId,
                        request.RequesterUid,
                        request.RequesterUidType,
                        request.TargetUid,
                        request.TargetUidType,
                        request.TargetName,
                        request.StartDate,
                        request.EndDate,
                        request.EventTypes,
                        fileFullPath
                    }, cancellationToken);
            }

            AddAuditLog(LogEventCode.GET_LOG_TO_USER, LogEventLifecycle.SUCCESS, payload: new SortedDictionary<string, object>
            {
                { AuditLoggingKeys.Request, request },
                { AuditLoggingKeys.RequesterUid, GetUid() },
                { AuditLoggingKeys.RequesterUidType, GetUidType() },
                {"UserId", GetUserId() }
            });

            return Accepted();
        }

        var csvFileName = $"report_toUser-{request.StartDate:yyyyMMdd}-{request.EndDate:yyyyMMdd}.csv";

        // Creating a pipe stream to transform the JSON lines at write time.
        var pipeStream = new AnonymousPipeServerStream(PipeDirection.Out);
        var clientStream = new AnonymousPipeClientStream(PipeDirection.In, pipeStream.GetClientHandleAsString());

        Response.RegisterForDisposeAsync(pipeStream);
        Response.RegisterForDisposeAsync(clientStream);

        _ = Task.Run(async () =>
        {
            await using var writer = new StreamWriter(pipeStream, Encoding.UTF8);
            var csvConfig = new CsvConfiguration(CultureInfo.InvariantCulture)
            {
                Encoding = Encoding.UTF8,
                HasHeaderRecord = true,
                NewLine = Environment.NewLine,
            };
            await using var csv = new CsvWriter(writer, csvConfig);

            using var aes = Aes.Create();
            aes.Key = Encoding.UTF8.GetBytes(_aesOptions.Key);
            aes.Mode = CipherMode.ECB;
            aes.Padding = PaddingMode.PKCS7;
            var decryptor = aes.CreateDecryptor(aes.Key, aes.IV);

            csv.WriteHeader(typeof(LogToUserResultDTO));
            await csv.NextRecordAsync();

            using var readStream = System.IO.File.Open(fileFullPath, FileMode.Open, FileAccess.Read, FileShare.Read);
            using var reader = new StreamReader(readStream);
            string? line;
            while ((line = await reader.ReadLineAsync()) != null && !cancellationToken.IsCancellationRequested)
            {
                var data = JsonConvert.DeserializeObject<LogToUserResult>(line);
                if (data == null) continue;

                DecryptLogRecordData(data, decryptor);
                var dto = LogToUserResultDTO.Create(data);

                csv.WriteRecord(dto);
                await csv.NextRecordAsync();
            }

            await csv.FlushAsync();
            await writer.FlushAsync();
            await pipeStream.FlushAsync(cancellationToken);
        }, cancellationToken);

        return File(clientStream, "text/csv", csvFileName);
    }

    private static void DecryptLogRecordData(LogResult logRecord, ICryptoTransform decryptor)
    {
        try
        {
            logRecord.RequesterUserId = Decrypt(logRecord.RequesterUserId, decryptor);
        }
        catch
        {
            // The value wasn't encrypted. Return it as-is.
        }
        try
        {
            logRecord.TargetUserId = Decrypt(logRecord.TargetUserId, decryptor);
        }
        catch
        {
            // The value wasn't encrypted. Return it as-is.
        }
        if (logRecord.EventPayload is null)
        {
            return;
        }

        if (logRecord.EventPayload.ContainsKey(AuditLoggingKeys.Request) && logRecord.EventPayload[AuditLoggingKeys.Request] is not null)
        {
            try
            {
                logRecord.EventPayload[AuditLoggingKeys.Request] = Decrypt(logRecord.EventPayload[AuditLoggingKeys.Request].ToString(), decryptor);
            }
            catch
            {
                // The value wasn't encrypted. Return it as-is.
            }
        }

        foreach (var key in AuditLoggingKeys.GetEncryptablePayloadKeys())
        {
            if (logRecord.EventPayload.ContainsKey(key) && logRecord.EventPayload[key] is not null)
            {
                try
                {
                    logRecord.EventPayload[key] = Decrypt(logRecord.EventPayload[key].ToString(), decryptor);
                }
                catch
                {
                    // The value wasn't encrypted. Return it as-is.
                }
            }
        }
    }

    private static string Decrypt(string? dataToDecrypt, ICryptoTransform decryptor)
    {
        if (string.IsNullOrEmpty(dataToDecrypt) || string.IsNullOrWhiteSpace(dataToDecrypt))
        {
            return string.Empty;
        }

        var buffer = Convert.FromBase64String(dataToDecrypt);
        using var memoryStream = new MemoryStream(buffer);
        using var cryptoStream = new CryptoStream(memoryStream, decryptor, CryptoStreamMode.Read);
        using var streamReader = new StreamReader(cryptoStream);

        return streamReader.ReadToEnd();
    }
}
